<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UncaughtExceptionHandlers.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Dropwizard GELF Bundle</a> &gt; <a href="index.source.html" class="el_package">net.gini.dropwizard.gelf.logging</a> &gt; <span class="el_source">UncaughtExceptionHandlers.java</span></div><h1>UncaughtExceptionHandlers.java</h1><pre class="source lang-java linenums">package net.gini.dropwizard.gelf.logging;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static java.lang.String.format;
import static java.util.Objects.requireNonNull;

/**
 * Simple factory for a {@link Thread.UncaughtExceptionHandler} which logs the last uncaught exception with a SLF4J {@link
 * Logger} on ERROR level.
 */
public final class UncaughtExceptionHandlers {

<span class="nc" id="L15">    private UncaughtExceptionHandlers() {</span>
<span class="nc" id="L16">    }</span>

    /**
     * Returns a builder for an exception handler that bootstraps a GELF log appender, logs the uncaught exception
     * and then exits the system. This is particularly useful for the main thread, which may start up other,
     * non-daemon threads, but fail to fully initialize the application successfully.
     * &lt;br&gt;
     * Example usage:
     * &lt;pre&gt;public static void main(String[] args) {
     *   Thread.currentThread().setUncaughtExceptionHandler(
     *       UncaughtExceptionHandlers.loggingSystemExitBuilder(&quot;some-service&quot;, &quot;log.example.com&quot;).build());
     *   ...
     * &lt;/pre&gt;
     *
     * @param facility The facility to use in the GELF messages
     * @param host     The host of the Graylog server
     * @return builder object for building the exception handler
     */
    public static LoggingSystemExitBuilder loggingSystemExitBuilder(final String facility, final String host) {
<span class="nc" id="L35">        return new LoggingSystemExitBuilder(facility, host);</span>
    }

    /**
     * Returns an exception handler that logs the uncaught exception to {@code System.err} and then exits the system.
     * This is particularly useful for the main thread, which may start up other, non-daemon threads, but fail to fully
     * initialize the application successfully. &lt;br&gt; Example usage:
     * &lt;pre&gt;public static void main(String[] args) {
     *   Thread.currentThread().setUncaughtExceptionHandler(
     *       UncaughtExceptionHandlers.systemExit());
     *   ...
     * &lt;/pre&gt;
     *
     * @return exception handler
     */
    public static Thread.UncaughtExceptionHandler systemExit() {
<span class="nc" id="L51">        return new Exiter(Runtime.getRuntime());</span>
    }

    public static final class LoggingSystemExitBuilder {

        private String facility;
        private String host;
<span class="nc" id="L58">        private int port = 12201;</span>
<span class="nc" id="L59">        private boolean cleanRootLogger = false;</span>
<span class="nc" id="L60">        private boolean logToStderr = true;</span>

<span class="nc" id="L62">        LoggingSystemExitBuilder(final String facility, final String host) {</span>
<span class="nc" id="L63">            this.facility = requireNonNull(facility);</span>
<span class="nc" id="L64">            this.host = requireNonNull(host);</span>
<span class="nc" id="L65">        }</span>

        /**
         * Sets the port of the Graylog server.
         *
         * @param port The port of the Graylog server.
         * @return {@link LoggingSystemExitBuilder} instance
         */
        public LoggingSystemExitBuilder port(final int port) {
<span class="nc" id="L74">            this.port = port;</span>
<span class="nc" id="L75">            return this;</span>
        }

        /**
         * Sets whether all existing appenders should be detached from the root logger.
         *
         * @param cleanRootLogger If true, detach and stop all other appenders from the root logger
         * @return {@link LoggingSystemExitBuilder} instance
         */
        public LoggingSystemExitBuilder cleanRootLogger(final boolean cleanRootLogger) {
<span class="nc" id="L85">            this.cleanRootLogger = cleanRootLogger;</span>
<span class="nc" id="L86">            return this;</span>
        }

        /**
         * Sets whether the stacktrace of the uncaught exception should be printed to {@code System.err}.
         *
         * @param logToStderr If true, print the stacktrace to {@code System.err}
         * @return {@link LoggingSystemExitBuilder} instance
         */
        public LoggingSystemExitBuilder logToStderr(final boolean logToStderr) {
<span class="nc" id="L96">            this.logToStderr = logToStderr;</span>
<span class="nc" id="L97">            return this;</span>
        }

        public Thread.UncaughtExceptionHandler build() {
<span class="nc" id="L101">            return new LoggingExiter(Runtime.getRuntime(), facility, host, port, cleanRootLogger, logToStderr);</span>
        }
    }

    /**
     * Exception handler that exits the system. Bootstrap a GELF log appender and logs the uncaught exception.
     * Optionally prints the stacktrace to {@code System.err} as well.
     */
    private static final class LoggingExiter implements Thread.UncaughtExceptionHandler {

<span class="nc" id="L111">        private static final Logger LOGGER = LoggerFactory.getLogger(Exiter.class);</span>

        private final Runtime runtime;
        private final String name;
        private final String host;
        private final int port;
        private final boolean cleanRootLogger;
        private final boolean logToStderr;

        private LoggingExiter(final Runtime runtime, final String name, final String host, final int port,
<span class="nc" id="L121">                              final boolean cleanRootLogger, final boolean logToStderr) {</span>
<span class="nc" id="L122">            this.runtime = runtime;</span>
<span class="nc" id="L123">            this.name = name;</span>
<span class="nc" id="L124">            this.host = host;</span>
<span class="nc" id="L125">            this.port = port;</span>
<span class="nc" id="L126">            this.cleanRootLogger = cleanRootLogger;</span>
<span class="nc" id="L127">            this.logToStderr = logToStderr;</span>
<span class="nc" id="L128">        }</span>

        @Override
        public void uncaughtException(final Thread t, final Throwable e) {
            // Re-initialize logging system (as dropwizard likely has stopped it)
<span class="nc" id="L133">            GelfBootstrap.bootstrap(name, host, port, cleanRootLogger);</span>
            // Log the exception
<span class="nc" id="L135">            final String msg = format(&quot;Caught an exception in %s.  Shutting down&quot;, t);</span>
<span class="nc" id="L136">            LOGGER.error(msg, e);</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">            if (logToStderr) {</span>
<span class="nc" id="L138">                System.err.print(msg);</span>
<span class="nc" id="L139">                System.err.print(&quot;! &quot;);</span>
<span class="nc" id="L140">                e.printStackTrace(System.err);</span>
            }
            // Stop appenders (should flush all existing messages)
<span class="nc" id="L143">            getRootLogger().detachAndStopAllAppenders();</span>
            // Terminate the JVM
<span class="nc" id="L145">            runtime.exit(1);</span>
<span class="nc" id="L146">        }</span>

        private ch.qos.logback.classic.Logger getRootLogger() {
<span class="nc" id="L149">            return (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);</span>
        }
    }

    private static final class Exiter implements Thread.UncaughtExceptionHandler {

        private final Runtime runtime;

<span class="nc" id="L157">        private Exiter(final Runtime runtime) {</span>
<span class="nc" id="L158">            this.runtime = requireNonNull(runtime);</span>
<span class="nc" id="L159">        }</span>

        @Override
        public void uncaughtException(final Thread t, final Throwable e) {
<span class="nc" id="L163">            System.err.print(format(&quot;Caught an exception in %s.  Shutting down! &quot;, t));</span>
<span class="nc" id="L164">            e.printStackTrace(System.err);</span>
<span class="nc" id="L165">            runtime.exit(1);</span>
<span class="nc" id="L166">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>