<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GelfLoggingFilter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Dropwizard GELF Bundle</a> &gt; <a href="index.source.html" class="el_package">net.gini.dropwizard.gelf.filters</a> &gt; <span class="el_source">GelfLoggingFilter.java</span></div><h1>GelfLoggingFilter.java</h1><pre class="source lang-java linenums">package net.gini.dropwizard.gelf.filters;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Stopwatch;
import com.google.common.io.CountingOutputStream;
import com.google.common.net.HttpHeaders;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import javax.servlet.AsyncEvent;
import javax.servlet.AsyncListener;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.WriteListener;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import java.io.IOException;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

/**
 * A {@link Filter} which logs requests and adds some data about it to the logger's {@link MDC}.
 */
<span class="fc" id="L31">public class GelfLoggingFilter implements Filter {</span>

<span class="fc" id="L33">    private static final Logger LOG = LoggerFactory.getLogger(GelfLoggingFilter.class);</span>

    /**
     * Called by the web container to indicate to a filter that it is
     * being placed into service.
     * &lt;p&gt;The servlet container calls the init
     * method exactly once after instantiating the filter. The init
     * method must complete successfully before the filter is asked to do any
     * filtering work.
     * &lt;/p&gt;
     * &lt;p&gt;The web container cannot place the filter into service if the init
     * method either
     * &lt;ol&gt;
     * &lt;li&gt;Throws a ServletException
     * &lt;li&gt;Does not return within a time period defined by the web container
     * &lt;/ol&gt;
     *
     * @param filterConfig the {@link FilterChain} for this {@link Filter}
     * @throws ServletException if something goes wrong
     */
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // Do nothing
<span class="fc" id="L56">    }</span>

    /**
     * The &lt;code&gt;doFilter&lt;/code&gt; method of the Filter is called by the
     * container each time a request/response pair is passed through the
     * chain due to a client request for a resource at the end of the chain.
     * The FilterChain passed in to this method allows the Filter to pass
     * on the request and response to the next entity in the chain.
     * &lt;p&gt;A typical implementation of this method would follow the following
     * pattern:
     * &lt;ol&gt;
     * &lt;li&gt;Examine the request
     * &lt;li&gt;Optionally wrap the request object with a custom implementation to
     * filter content or headers for input filtering
     * &lt;li&gt;Optionally wrap the response object with a custom implementation to
     * filter content or headers for output filtering
     * &lt;li&gt;
     * &lt;ul&gt;
     * &lt;li&gt;&lt;strong&gt;Either&lt;/strong&gt; invoke the next entity in the chain
     * using the FilterChain object
     * (&lt;code&gt;chain.doFilter()&lt;/code&gt;),
     * &lt;li&gt;&lt;strong&gt;or&lt;/strong&gt; not pass on the request/response pair to
     * the next entity in the filter chain to
     * block the request processing
     * &lt;/ul&gt;
     * &lt;li&gt;Directly set headers on the response after invocation of the
     * next entity in the filter chain.
     * &lt;/ol&gt;
     */
    @Override
    public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain)
            throws IOException, ServletException {
        // It's quite safe to assume that we only receive HTTP requests
<span class="fc" id="L89">        final HttpServletRequest httpRequest = (HttpServletRequest) request;</span>
<span class="fc" id="L90">        final HttpServletResponse httpResponse = (HttpServletResponse) response;</span>

<span class="fc" id="L92">        final StringBuilder buf = new StringBuilder(256);</span>

<span class="fc" id="L94">        final Optional&lt;String&gt; address = Optional.ofNullable(httpRequest.getHeader(HttpHeaders.X_FORWARDED_FOR));</span>
<span class="fc" id="L95">        final String clientAddress = address.orElse(request.getRemoteAddr());</span>

<span class="fc" id="L97">        buf.append(clientAddress);</span>
<span class="fc" id="L98">        buf.append(&quot; - &quot;);</span>

<span class="fc" id="L100">        final String authType = httpRequest.getAuthType();</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (authType != null) {</span>
<span class="nc" id="L102">            buf.append(httpRequest.getUserPrincipal().getName());</span>
        } else {
<span class="fc" id="L104">            buf.append(&quot;-&quot;);</span>
        }
<span class="fc" id="L106">        buf.append(&quot; \&quot;&quot;);</span>
<span class="fc" id="L107">        buf.append(httpRequest.getMethod());</span>
<span class="fc" id="L108">        buf.append(' ');</span>
<span class="fc" id="L109">        buf.append(httpRequest.getRequestURI());</span>
<span class="fc" id="L110">        buf.append(' ');</span>
<span class="fc" id="L111">        buf.append(request.getProtocol());</span>
<span class="fc" id="L112">        buf.append(&quot;\&quot; &quot;);</span>

<span class="fc" id="L114">        final CountingHttpServletResponseWrapper responseWrapper = new CountingHttpServletResponseWrapper(httpResponse);</span>

<span class="fc" id="L116">        final Stopwatch stopwatch = Stopwatch.createUnstarted();</span>
<span class="fc" id="L117">        stopwatch.start();</span>

        try {
<span class="fc" id="L120">            chain.doFilter(request, responseWrapper);</span>
        } finally {
<span class="fc bfc" id="L122" title="All 2 branches covered.">            if (request.isAsyncStarted()) {</span>
<span class="fc" id="L123">                final AsyncListener listener =</span>
                        new LoggingAsyncListener(buf, stopwatch, authType, clientAddress, httpRequest,
                                responseWrapper);
<span class="fc" id="L126">                request.getAsyncContext().addListener(listener);</span>
<span class="fc" id="L127">            } else {</span>
<span class="fc" id="L128">                logRequest(buf, stopwatch, authType, clientAddress, httpRequest, responseWrapper);</span>
            }
        }
<span class="fc" id="L131">    }</span>

    private static void logRequest(final StringBuilder buf, final Stopwatch stopwatch, final String authType,
                                   final String clientAddress,
                                   final HttpServletRequest httpRequest,
                                   final CountingHttpServletResponseWrapper responseWrapper) {
<span class="fc" id="L137">        stopwatch.stop();</span>

<span class="fc" id="L139">        buf.append(responseWrapper.getStatus());</span>
<span class="fc" id="L140">        buf.append(&quot; &quot;);</span>
<span class="fc" id="L141">        buf.append(responseWrapper.getCount());</span>

<span class="fc" id="L143">        final String userAgent = httpRequest.getHeader(HttpHeaders.USER_AGENT);</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        if (userAgent != null) {</span>
<span class="fc" id="L145">            MDC.put(AdditionalKeys.USER_AGENT, userAgent);</span>
        }

<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (authType != null) {</span>
<span class="nc" id="L149">            MDC.put(AdditionalKeys.REQ_AUTH, authType);</span>
<span class="nc" id="L150">            MDC.put(AdditionalKeys.PRINCIPAL, httpRequest.getUserPrincipal().getName());</span>
        }

<span class="fc" id="L153">        MDC.put(AdditionalKeys.REMOTE_ADDRESS, clientAddress);</span>
<span class="fc" id="L154">        MDC.put(AdditionalKeys.HTTP_METHOD, httpRequest.getMethod());</span>
<span class="fc" id="L155">        MDC.put(AdditionalKeys.PROTOCOL, httpRequest.getProtocol());</span>
<span class="fc" id="L156">        MDC.put(AdditionalKeys.REQ_URI, httpRequest.getRequestURI());</span>
<span class="fc" id="L157">        MDC.put(AdditionalKeys.REQ_LENGTH, String.valueOf(httpRequest.getContentLength()));</span>
<span class="fc" id="L158">        MDC.put(AdditionalKeys.REQ_CONTENT_TYPE, httpRequest.getContentType());</span>
<span class="fc" id="L159">        MDC.put(AdditionalKeys.REQ_ENCODING, httpRequest.getCharacterEncoding());</span>
<span class="fc" id="L160">        MDC.put(AdditionalKeys.RESP_STATUS, String.valueOf(responseWrapper.getStatus()));</span>
<span class="fc" id="L161">        MDC.put(AdditionalKeys.RESP_CONTENT_TYPE, responseWrapper.getContentType());</span>
<span class="fc" id="L162">        MDC.put(AdditionalKeys.RESP_ENCODING, responseWrapper.getCharacterEncoding());</span>
<span class="fc" id="L163">        MDC.put(AdditionalKeys.RESP_TIME, String.valueOf(stopwatch.elapsed(TimeUnit.NANOSECONDS)));</span>
<span class="fc" id="L164">        MDC.put(AdditionalKeys.RESP_LENGTH, String.valueOf(responseWrapper.getCount()));</span>

<span class="fc" id="L166">        LOG.info(buf.toString());</span>

<span class="fc" id="L168">        clearMDC();</span>
<span class="fc" id="L169">    }</span>

    /**
     * Called by the web container to indicate to a filter that it is being
     * taken out of service.
     * &lt;p&gt;This method is only called once all threads within the filter's
     * doFilter method have exited or after a timeout period has passed.
     * After the web container calls this method, it will not call the
     * doFilter method again on this instance of the filter.
     * &lt;/p&gt;
     * &lt;p&gt;This method gives the filter an opportunity to clean up any
     * resources that are being held (for example, memory, file handles,
     * threads) and make sure that any persistent state is synchronized
     * with the filter's current state in memory.
     * &lt;/p&gt;
     */
    @Override
    public void destroy() {
        // Do nothing
<span class="fc" id="L188">    }</span>

    private static void clearMDC() {
<span class="fc" id="L191">        MDC.remove(AdditionalKeys.USER_AGENT);</span>
<span class="fc" id="L192">        MDC.remove(AdditionalKeys.REQ_AUTH);</span>
<span class="fc" id="L193">        MDC.remove(AdditionalKeys.PRINCIPAL);</span>
<span class="fc" id="L194">        MDC.remove(AdditionalKeys.REMOTE_ADDRESS);</span>
<span class="fc" id="L195">        MDC.remove(AdditionalKeys.HTTP_METHOD);</span>
<span class="fc" id="L196">        MDC.remove(AdditionalKeys.PROTOCOL);</span>
<span class="fc" id="L197">        MDC.remove(AdditionalKeys.REQ_URI);</span>
<span class="fc" id="L198">        MDC.remove(AdditionalKeys.REQ_LENGTH);</span>
<span class="fc" id="L199">        MDC.remove(AdditionalKeys.REQ_CONTENT_TYPE);</span>
<span class="fc" id="L200">        MDC.remove(AdditionalKeys.REQ_ENCODING);</span>
<span class="fc" id="L201">        MDC.remove(AdditionalKeys.RESP_STATUS);</span>
<span class="fc" id="L202">        MDC.remove(AdditionalKeys.RESP_CONTENT_TYPE);</span>
<span class="fc" id="L203">        MDC.remove(AdditionalKeys.RESP_ENCODING);</span>
<span class="fc" id="L204">        MDC.remove(AdditionalKeys.RESP_TIME);</span>
<span class="fc" id="L205">        MDC.remove(AdditionalKeys.RESP_LENGTH);</span>
<span class="fc" id="L206">    }</span>

    /**
     * An implementation of {@link ServletOutputStream} which counts the bytes being
     * written using a {@link CountingOutputStream}.
     */
    private static final class CountingServletOutputStream extends ServletOutputStream {

        private final CountingOutputStream outputStream;

<span class="fc" id="L216">        private CountingServletOutputStream(ServletOutputStream servletOutputStream) {</span>
<span class="fc" id="L217">            this.outputStream = new CountingOutputStream(servletOutputStream);</span>
<span class="fc" id="L218">        }</span>

        /**
         * Writes the specified byte to this output stream. The general
         * contract for &lt;code&gt;write&lt;/code&gt; is that one byte is written
         * to the output stream. The byte to be written is the eight
         * low-order bits of the argument &lt;code&gt;b&lt;/code&gt;. The 24
         * high-order bits of &lt;code&gt;b&lt;/code&gt; are ignored.
         * &lt;p&gt;
         * Subclasses of &lt;code&gt;OutputStream&lt;/code&gt; must provide an
         * implementation for this method.
         * &lt;/p&gt;
         *
         * @param b the &lt;code&gt;byte&lt;/code&gt;.
         * @throws java.io.IOException if an I/O error occurs. In particular,
         *                             an &lt;code&gt;IOException&lt;/code&gt; may be thrown if the
         *                             output stream has been closed.
         */
        @Override
        public void write(int b) throws IOException {
<span class="fc" id="L238">            outputStream.write(b);</span>
<span class="fc" id="L239">        }</span>

        public long getCount() {
<span class="fc" id="L242">            return outputStream.getCount();</span>
        }

        @Override
        public boolean isReady() {
<span class="nc" id="L247">            return true;</span>
        }

        @Override
        public void setWriteListener(WriteListener writeListener) {
            // NOP
<span class="nc" id="L253">        }</span>
    }

    /**
     * An implementation of {@link HttpServletResponseWrapper} which counts the bytes being written as the response
     * body using a {@link CountingServletOutputStream}.
     */
    private static final class CountingHttpServletResponseWrapper extends HttpServletResponseWrapper {
        private CountingServletOutputStream outputStream;

        private CountingHttpServletResponseWrapper(HttpServletResponse response) throws IOException {
<span class="fc" id="L264">            super(response);</span>
<span class="fc" id="L265">        }</span>

        /**
         * The default behavior of this method is to return getOutputStream()
         * on the wrapped response object.
         */
        @Override
        public ServletOutputStream getOutputStream() throws IOException {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">            if (outputStream == null) {</span>
<span class="fc" id="L274">                outputStream = new CountingServletOutputStream(getResponse().getOutputStream());</span>
            }
<span class="fc" id="L276">            return outputStream;</span>
        }

        /**
         * Get the number of bytes written to the response output stream.
         *
         * @return the number of bytes written to the response output stream
         */
        public long getCount() {
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">            return outputStream == null ? 0L : outputStream.getCount();</span>
        }

        /**
         * The default behavior of this method is to call resetBuffer() on the wrapped response object.
         *
         * @see javax.servlet.http.HttpServletResponseWrapper#resetBuffer()
         */
        @Override
        public void resetBuffer() {
<span class="nc" id="L295">            super.resetBuffer();</span>
<span class="nc" id="L296">            outputStream = null;</span>
<span class="nc" id="L297">        }</span>

        /**
         * The default behavior of this method is to call reset() on the wrapped response object.
         *
         * @see javax.servlet.http.HttpServletResponseWrapper#reset()
         */
        @Override
        public void reset() {
<span class="nc" id="L306">            super.reset();</span>
<span class="nc" id="L307">            outputStream = null;</span>
<span class="nc" id="L308">        }</span>
    }

    private static class LoggingAsyncListener implements AsyncListener {

        private final StringBuilder buf;
        private final Stopwatch stopwatch;
        private final String authType;
        private final String clientAddress;
        private final HttpServletRequest httpRequest;
        private final CountingHttpServletResponseWrapper responseWrapper;

        public LoggingAsyncListener(final StringBuilder buf, final Stopwatch stopwatch, final String authType,
                                    final String clientAddress,
                                    final HttpServletRequest httpRequest,
<span class="fc" id="L323">                                    final CountingHttpServletResponseWrapper responseWrapper) {</span>
<span class="fc" id="L324">            this.buf = buf;</span>
<span class="fc" id="L325">            this.stopwatch = stopwatch;</span>
<span class="fc" id="L326">            this.authType = authType;</span>
<span class="fc" id="L327">            this.clientAddress = clientAddress;</span>
<span class="fc" id="L328">            this.httpRequest = httpRequest;</span>
<span class="fc" id="L329">            this.responseWrapper = responseWrapper;</span>
<span class="fc" id="L330">        }</span>

        @Override
        public void onComplete(final AsyncEvent event) throws IOException {
<span class="fc" id="L334">            logRequest(buf, stopwatch, authType, clientAddress, httpRequest, responseWrapper);</span>
<span class="fc" id="L335">        }</span>

        @Override
        public void onTimeout(final AsyncEvent event) throws IOException {
            // Intentionally empty
<span class="nc" id="L340">        }</span>

        @Override
        public void onError(final AsyncEvent event) throws IOException {
            // Intentionally empty
<span class="nc" id="L345">        }</span>

        @Override
        public void onStartAsync(final AsyncEvent event) throws IOException {
            // Intentionally empty
<span class="nc" id="L350">        }</span>
    }

    @VisibleForTesting
    static final class AdditionalKeys {

        public static final String USER_AGENT = &quot;userAgent&quot;;
        public static final String REQ_AUTH = &quot;requestAuth&quot;;
        public static final String PRINCIPAL = &quot;userPrincipal&quot;;
        public static final String REMOTE_ADDRESS = &quot;remoteAddress&quot;;
        public static final String HTTP_METHOD = &quot;httpMethod&quot;;
        public static final String PROTOCOL = &quot;protocol&quot;;
        public static final String REQ_URI = &quot;requestUri&quot;;
        public static final String REQ_LENGTH = &quot;requestLength&quot;;
        public static final String REQ_CONTENT_TYPE = &quot;requestContentType&quot;;
        public static final String REQ_ENCODING = &quot;requestEncoding&quot;;
        public static final String RESP_STATUS = &quot;responseStatus&quot;;
        public static final String RESP_CONTENT_TYPE = &quot;responseContentType&quot;;
        public static final String RESP_ENCODING = &quot;responseEncoding&quot;;
        public static final String RESP_TIME = &quot;responseTimeNanos&quot;;
        public static final String RESP_LENGTH = &quot;responseLength&quot;;

        private AdditionalKeys() {
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>